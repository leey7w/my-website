<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gravity Toys â€” Space Emoji Sandbox</title>
<style>
  :root{
    --bg:#000; --hud:#0b0b12cc; --text:#e8eefc; --muted:#a7b0c3;
    --accent:#78f3ff; --good:#6bffb0;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial}
  canvas{display:block;width:100%;height:100%;touch-action:none;cursor:crosshair}
  .hud{
    position:fixed;left:14px;top:14px;z-index:10;
    background:var(--hud);backdrop-filter: blur(6px) saturate(140%);
    border:1px solid #1a2030; border-radius:12px; padding:10px 12px;
    box-shadow:0 10px 30px rgba(0,0,0,.45)
  }
  .hud b{font-weight:700}
  .corner2{
    position:fixed;right:14px;bottom:14px;z-index:10;
    color:var(--muted);opacity:.9;user-select:none
  }
  .toast{
    position:fixed;left:50%;top:18px;transform:translateX(-50%);
    background:#0b1320e6;border:1px solid #1d2a44;color:#d9e7ff;
    padding:10px 14px;border-radius:999px;display:none;font-weight:600;
    box-shadow:0 12px 30px rgba(0,0,0,.55);z-index:20
  }
  .toast.show{display:inline-block;animation:pop .5s ease, fade 2.4s 1.1s forwards}
  @keyframes pop{0%{transform:translateX(-50%) scale(.85);opacity:.3} 100%{transform:translateX(-50%) scale(1);opacity:1}}
  @keyframes fade{to{opacity:0;transform:translateX(-50%) translateY(-12px)}}
  .hint{
    position:fixed;right:14px;top:14px;z-index:9;color:#9fb2d8;
    background:#0b0b12cc;border:1px solid #1a2030;border-radius:12px;padding:10px 12px
  }
  .hint span{display:block;font-size:13px;opacity:.9}
  .badge{
    display:inline-block;margin-left:6px;padding:2px 8px;border-radius:999px;
    background:#0e1a24;border:1px solid #173043;font-size:12px;color:#9bd9ff
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud" id="hud">
  <div><b>Spawns:</b> <span id="count">0</span> <span class="badge" id="unlocks">5 unlocked</span></div>
</div>

<div class="hint">
  <span>Click: spawn emoji</span>
  <span>Drag: gravity well</span>
  <span>Double-click: supernova</span>
</div>

<div class="toast" id="toast">Unlocked: ðŸ¦–</div>

<div class="corner2">Gravity Toys Â· single-file canvas</div>

<script>
(() => {
  // --- Canvas setup with HiDPI scaling
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0, DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
  function resize(){
    const { innerWidth, innerHeight } = window;
    W = innerWidth; H = innerHeight;
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // --- World state
  const baseEmojis = ['ðŸŒŽ','ðŸŒ•','ðŸš€','â­','ðŸ’«'];
  const unlockPool = ['ðŸ¦–','ðŸ™','ðŸ•','ðŸª','â˜„ï¸','ðŸ¦„','ðŸŽˆ','ðŸŒˆ','ðŸ‰','ðŸ©','ðŸ§','ðŸ›°ï¸','ðŸ§Š','ðŸª©'];
  const unlocked = [...baseEmojis];

  const particles = [];
  let spawnCount = 0;
  const countEl = document.getElementById('count');
  const unlocksEl = document.getElementById('unlocks');
  const toastEl = document.getElementById('toast');

  // Background stars
  const stars = Array.from({length: 160}, () => ({
    x: Math.random()*W,
    y: Math.random()*H,
    r: Math.random()*1.2+0.3,
    a: Math.random()*0.6+0.2,
    z: Math.random()*0.7+0.3
  }));

  // Mouse / touch
  const mouse = { x: W/2, y: H/2, down:false, dragging:false, moved:false, lastDown:0 };
  const dragInfluence = 120;  // px radius of strong pull
  const G_mouse = 1200;       // mouse gravity strength
  const G_center = 4;         // mild attraction to center to keep things together
  const air = 0.995;          // damping (space-ish)

  // Helpers
  const rand = (a,b)=>a+Math.random()*(b-a);
  const pick = arr => arr[(Math.random()*arr.length)|0];

  function spawnEmoji(x, y, vScale=1) {
    const e = pick(unlocked);
    const size = rand(26, 48);
    const p = {
      x, y,
      vx: rand(-0.6,0.6)*vScale,
      vy: rand(-0.6,0.6)*vScale,
      size,
      mass: size*0.3,
      emoji: e,
      spin: rand(-0.003, 0.003),
      angle: Math.random()*Math.PI*2
    };
    particles.push(p);
    spawnCount++;
    countEl.textContent = spawnCount;

    // unlock new emoji every 10 spawns
    if (spawnCount % 10 === 0 && unlockPool.length) {
      const idx = (Math.random()*unlockPool.length)|0;
      const newOne = unlockPool.splice(idx,1)[0];
      unlocked.push(newOne);
      unlocksEl.textContent = unlocked.length + ' unlocked';
      showToast('Unlocked: ' + newOne);
      // small celebratory burst
      for (let i=0;i<6;i++){
        particles.push({
          x, y,
          vx: Math.cos(i/6*2*Math.PI)*rand(1.2,2.2),
          vy: Math.sin(i/6*2*Math.PI)*rand(1.2,2.2),
          size: rand(22,36),
          mass: rand(6,12),
          emoji: newOne,
          spin: rand(-0.004,0.004),
          angle: rand(0,Math.PI*2)
        });
      }
    }
  }

  function showToast(text){
    toastEl.textContent = text;
    toastEl.classList.remove('show');
    // trigger reflow to restart animation
    void toastEl.offsetWidth;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 2800);
  }

  // Initial sprinkle
  for (let i=0;i<10;i++) spawnEmoji(rand(0,W), rand(0,H), 0.2);

  // --- Events
  function getPos(e){
    if (e.touches && e.touches[0]) return {x:e.touches[0].clientX, y:e.touches[0].clientY};
    return {x:e.clientX, y:e.clientY};
  }

  canvas.addEventListener('mousedown', (e)=>{
    mouse.down = true; mouse.moved=false; mouse.lastDown = performance.now();
  });

  canvas.addEventListener('mousemove', (e)=>{
    const p = getPos(e);
    mouse.x = p.x; mouse.y = p.y;
    if (mouse.down) { mouse.dragging = true; mouse.moved = true; }
  });

  addEventListener('mouseup', (e)=>{
    // click (no drag) spawns
    if (!mouse.moved) {
      const p = getPos(e);
      spawnEmoji(p.x, p.y, 1.0);
    }
    mouse.down=false;
    // small delay before turning off dragging so final pull feels smooth
    setTimeout(()=> mouse.dragging=false, 30);
  });

  canvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); mouse.down=true; mouse.moved=false; const p=getPos(e); mouse.x=p.x; mouse.y=p.y;},{passive:false});
  canvas.addEventListener('touchmove',(e)=>{ e.preventDefault(); const p=getPos(e); mouse.x=p.x; mouse.y=p.y; mouse.dragging=true; mouse.moved=true;},{passive:false});
  canvas.addEventListener('touchend',(e)=>{ e.preventDefault(); if(!mouse.moved){ const p=mouse; spawnEmoji(p.x,p.y,1.0);} mouse.down=false; setTimeout(()=>mouse.dragging=false,30);},{passive:false});

  // Supernova on double click (or double tap timing)
  canvas.addEventListener('dblclick', (e)=>{
    const {x,y} = getPos(e);
    supernova(x,y);
  });
  // double-tap fallback for touch
  let lastTap = 0;
  canvas.addEventListener('touchend', ()=>{
    const t = performance.now();
    if (t - lastTap < 280) {
      supernova(mouse.x, mouse.y);
    }
    lastTap = t;
  });

  function supernova(x,y){
    const power = 4.2; // outward speed multiplier
    for (const p of particles) {
      const dx = p.x - x, dy = p.y - y;
      let d = Math.hypot(dx,dy) || 1;
      // outward impulse
      const scale = power / (0.5 + d*0.01);
      p.vx += (dx/d) * scale;
      p.vy += (dy/d) * scale;
    }
    showToast('ðŸ’¥ Supernova!');
  }

  // --- Physics + render loop
  function step(dt){
    // background: stars + faint vignette
    ctx.clearRect(0,0,W,H);
    // vignette
    const g = ctx.createRadialGradient(W*0.5,H*0.5,0, W*0.5,H*0.5, Math.max(W,H)*0.7);
    g.addColorStop(0,'rgba(10,10,18,0)');
    g.addColorStop(1,'rgba(0,0,0,0.9)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // twinkling stars
    ctx.save();
    for (let s of stars){
      s.a += (Math.random()-0.5)*0.04;
      s.a = Math.max(0.15, Math.min(1, s.a));
      ctx.globalAlpha = s.a * s.z;
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fillStyle='#9db6ff'; ctx.fill();
    }
    ctx.restore();

    const cx = W/2, cy = H/2;

    for (const p of particles){
      // mild attraction to center
      let dx = cx - p.x, dy = cy - p.y;
      let d = Math.hypot(dx,dy) || 1;
      const f = (G_center * p.mass) / (d*d);
      p.vx += (dx/d) * f * dt;
      p.vy += (dy/d) * f * dt;

      // mouse drag gravity well
      if (mouse.dragging){
        const mdx = mouse.x - p.x, mdy = mouse.y - p.y;
        const md = Math.hypot(mdx,mdy) || 1;
        // Stronger within influence radius, softer beyond
        const strength = (md < dragInfluence ? 1 : dragInfluence/md);
        const mf = (G_mouse * strength * p.mass) / (md*md);
        p.vx += (mdx/md) * mf * dt;
        p.vy += (mdy/md) * mf * dt;
      }

      // integrate
      p.vx *= air; p.vy *= air;
      p.x += p.vx * 60 * dt;
      p.y += p.vy * 60 * dt;
      p.angle += p.spin;

      // wrap around edges (toroidal space)
      if (p.x < -60) p.x = W+60;
      if (p.x > W+60) p.x = -60;
      if (p.y < -60) p.y = H+60;
      if (p.y > H+60) p.y = -60;

      // draw emoji
      ctx.save();
      ctx.translate(p.x, p.y);
      // faint soft-glow behind the emoji
      const glow = ctx.createRadialGradient(0,0,1, 0,0, p.size*1.2);
      glow.addColorStop(0,'rgba(120,200,255,0.20)');
      glow.addColorStop(1,'rgba(120,200,255,0)');
      ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(0,0,p.size*1.2,0,Math.PI*2); ctx.fill();

      ctx.rotate(p.angle);
      ctx.font = `${p.size}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.emoji, 0, 0);
      ctx.restore();
    }
  }

  let last = performance.now();
  function loop(t){
    const now = t, dt = Math.min(0.033, (now - last)/1000); last = now;
    step(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
